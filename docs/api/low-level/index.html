



<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.2.0">
    
    
      
        <title>pygase.client - PyGaSe API Reference</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.750b69bd.css">
      
      
    
    
      <script src="../../assets/javascripts/modernizr.74668098.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    <body dir="ltr">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448"
    viewBox="0 0 416 448" id="__github">
  <path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19-18.125
        8.5-18.125-8.5-10.75-19-3.125-20.5 3.125-20.5 10.75-19 18.125-8.5
        18.125 8.5 10.75 19 3.125 20.5zM320 304q0 10-3.125 20.5t-10.75
        19-18.125 8.5-18.125-8.5-10.75-19-3.125-20.5 3.125-20.5 10.75-19
        18.125-8.5 18.125 8.5 10.75 19 3.125 20.5zM360
        304q0-30-17.25-51t-46.75-21q-10.25 0-48.75 5.25-17.75 2.75-39.25
        2.75t-39.25-2.75q-38-5.25-48.75-5.25-29.5 0-46.75 21t-17.25 51q0 22 8
        38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0
        37.25-1.75t35-7.375 30.5-15 20.25-25.75 8-38.375zM416 260q0 51.75-15.25
        82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5-41.75
        1.125q-19.5 0-35.5-0.75t-36.875-3.125-38.125-7.5-34.25-12.875-30.25-20.25-21.5-28.75q-15.5-30.75-15.5-82.75
        0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25
        30.875q36.75-8.75 77.25-8.75 37 0 70 8 26.25-20.5
        46.75-30.25t47.25-9.75q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34
        99.5z" />
</svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#pygaseclient" tabindex="1" class="md-skip">
        Skip to content
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../.." title="PyGaSe API Reference" class="md-header-nav__button md-logo">
          
            <i class="md-icon"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              PyGaSe API Reference
            </span>
            <span class="md-header-nav__topic">
              pygase.client
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  

<a href="https://github.com/sbischoff-ai/pygase/" title="Go to repository" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    GitHub
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../.." title="PyGaSe API Reference" class="md-nav__button md-logo">
      
        <i class="md-icon"></i>
      
    </a>
    PyGaSe API Reference
  </label>
  
    <div class="md-nav__source">
      


  

<a href="https://github.com/sbischoff-ai/pygase/" title="Go to repository" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../getting-started/" title="Getting Started" class="md-nav__link">
      Getting Started
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../main/" title="API" class="md-nav__link">
      API
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      Low Level API
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        Low Level API
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../client/" title="pygase.client" class="md-nav__link">
      pygase.client
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../backend/" title="pygase.backend" class="md-nav__link">
      pygase.backend
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../gamestate/" title="pygase.gamestate" class="md-nav__link">
      pygase.gamestate
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../connection/" title="pygase.connection" class="md-nav__link">
      pygase.connection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../event/" title="pygase.event" class="md-nav__link">
      pygase.event
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../utils/" title="pygase.utils" class="md-nav__link">
      pygase.utils
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#client" title="Client" class="md-nav__link">
    Client
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#connect" title="connect" class="md-nav__link">
    connect
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#connect_in_thread" title="connect_in_thread" class="md-nav__link">
    connect_in_thread
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#disconnect" title="disconnect" class="md-nav__link">
    disconnect
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#access_game_state" title="access_game_state" class="md-nav__link">
    access_game_state
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#wait_until" title="wait_until" class="md-nav__link">
    wait_until
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#try_to" title="try_to" class="md-nav__link">
    try_to
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dispatch_event" title="dispatch_event" class="md-nav__link">
    dispatch_event
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#register_event_handler" title="register_event_handler" class="md-nav__link">
    register_event_handler
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/sbischoff-ai/pygase/edit/master/docs/api/low-level.md" title="Edit this page" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                <h1 id="pygaseclient">pygase.client</h1>
<p>Connect to PyGaSe servers.</p>
<p><strong>Contents</strong></p>
<ul>
<li><code>Client</code>: main API class for PyGaSe clients</li>
</ul>
<h2 id="client">Client</h2>
<pre><code class="python">Client(self)
</code></pre>

<p>Exchange events with a PyGaSe server and access a synchronized game state.</p>
<p><strong>Attributes</strong></p>
<ul>
<li><code>connection (pygase.connection.ClientConnection)</code>: object that contains all networking information</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="python">from time import sleep
# Connect a client to the server from the Backend code example
client = Client()
client.connect_in_thread(hostname=&quot;localhost&quot;, port=8080)
# Increase `bar` five times, then reset `foo`
for i in range(5):
    client.dispatch_event(&quot;SET_BAR&quot;, new_bar=i)
    sleep(1)
client.dispatch_event(&quot;RESET_FOO&quot;)
</code></pre>

<h3 id="connect">connect</h3>
<pre><code class="python">Client.connect(self, port:int, hostname:str='localhost') -&gt; None
</code></pre>

<p>Open a connection to a PyGaSe server.</p>
<p>This is a blocking function but can also be spawned as a coroutine or in a thread
via <code>Client.connect_in_thread()</code>.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>port (int)</strong>: port number of the server to which to connect</li>
<li><strong>hostname (str)</strong>: hostname or IPv4 address of the server to which to connect</li>
</ul>
<h3 id="connect_in_thread">connect_in_thread</h3>
<pre><code class="python">Client.connect_in_thread(self, port:int, hostname:str='localhost') -&gt; threading.Thread
</code></pre>

<p>Open a connection in a seperate thread.</p>
<p>See <code>Client.connect()</code>.</p>
<p><strong>Returns</strong></p>
<p><code>threading.Thread</code>: the thread the client loop runs in</p>
<h3 id="disconnect">disconnect</h3>
<pre><code class="python">Client.disconnect(self, shutdown_server:bool=False) -&gt; None
</code></pre>

<p>Close the client connection.</p>
<p>This method can also be spawned as a coroutine.
shutdown_server (bool): wether or not the server should be shut down
    (only has an effect if the client has host permissions)</p>
<h3 id="access_game_state">access_game_state</h3>
<pre><code class="python">Client.access_game_state(self)
</code></pre>

<p>Return a context manager to access the shared game state.</p>
<p>Can be used in a <code>with</code> block to lock the synchronized <code>game_state</code> while working with it.</p>
<p><strong>Example</strong></p>
<pre><code class="python">with client.access_game_state() as game_state:
    do_stuff(game_state)
</code></pre>

<h3 id="wait_until">wait_until</h3>
<pre><code class="python">Client.wait_until(self, game_state_condition, timeout:float=1.0) -&gt; None
</code></pre>

<p>Block until a condition on the game state is satisfied.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>game_state_condition (callable)</strong>: function that takes a <code>pygase.GameState</code> instance and returns a bool</li>
<li><strong>timeout (float)</strong>: time in seconds after which to raise a <code>TimeoutError</code></li>
</ul>
<p><strong>Raises</strong></p>
<ul>
<li><code>TimeoutError</code>: if the condition is not met after <code>timeout</code> seconds</li>
</ul>
<h3 id="try_to">try_to</h3>
<pre><code class="python">Client.try_to(self, function, timeout:float=1.0)
</code></pre>

<p>Execute a function using game state attributes that might not yet exist.</p>
<p>This method repeatedly tries to execute <code>function(game_state)</code>, ignoring <code>KeyError</code> exceptions,
until it either worksor times out.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>function (callable)</strong>: function that takes a <code>pygase.GameState</code> instance and returns anything</li>
<li><strong>timeout (float)</strong>: time in seconds after which to raise a <code>TimeoutError</code></li>
</ul>
<p><strong>Returns</strong></p>
<p><code>any</code>: whatever <code>function(game_state)</code> returns</p>
<p><strong>Raises</strong></p>
<ul>
<li><code>TimeoutError</code>: if the function doesn't run through after <code>timeout</code> seconds</li>
</ul>
<h3 id="dispatch_event">dispatch_event</h3>
<pre><code class="python">Client.dispatch_event(self, event_type:str, *args, retries:int=0, ack_callback=None, **kwargs) -&gt; None
</code></pre>

<p>Send an event to the server.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>event_type (str)</strong>: event type identifier that links to a handler</li>
<li><strong>retries (int)</strong>: number of times the event is to be resent in case it times out</li>
<li><strong>ack_callback (callable, coroutine)</strong>: will be invoked after the event was received
Additional positional and keyword arguments will be sent as event data and passed to the handler function.</li>
</ul>
<hr />
<p><code>ack_callback</code> should not perform any long-running blocking operations (say a <code>while True</code> loop), as that will
block the connections asynchronous event loop. Use a coroutine instead, with appropriately placed <code>await</code>s.</p>
<h3 id="register_event_handler">register_event_handler</h3>
<pre><code class="python">Client.register_event_handler(self, event_type:str, event_handler_function) -&gt; None
</code></pre>

<p>Register an event handler for a specific event type.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>event_type (str)</strong>: event type to link the handler function to</li>
<li><strong>handler_func (callable, coroutine)</strong>: will be called for events of the given type</li>
</ul>
<h1 id="pygasebackend">pygase.backend</h1>
<p>Serve PyGaSe clients.</p>
<p>Provides the <code>Server</code> class and all PyGaSe components that deal with progression and syncing of game states.</p>
<p><strong>Contents</strong></p>
<ul>
<li><code>GameStateStore</code>: main API class for game state repositories</li>
<li><code>Server</code>: main API class for PyGaSe servers</li>
<li><code>GameStateMachine</code>: main API class for game logic components</li>
<li><code>Backend</code>: main API class for a fully integrated PyGaSe backend</li>
</ul>
<h2 id="gamestatestore">GameStateStore</h2>
<pre><code class="python">GameStateStore(self, initial_game_state:pygase.gamestate.GameState=None)
</code></pre>

<p>Provide access to a game state and manage state updates.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>inital_game_state (GameState)</strong>: state of the game before the simulation begins</li>
</ul>
<h3 id="get_update_cache">get_update_cache</h3>
<pre><code class="python">GameStateStore.get_update_cache(self) -&gt; list
</code></pre>

<p>Return the latest state updates.</p>
<h3 id="get_game_state">get_game_state</h3>
<pre><code class="python">GameStateStore.get_game_state(self) -&gt; pygase.gamestate.GameState
</code></pre>

<p>Return the current game state.</p>
<h3 id="push_update">push_update</h3>
<pre><code class="python">GameStateStore.push_update(self, update:pygase.gamestate.GameStateUpdate) -&gt; None
</code></pre>

<p>Push a new state update to the update cache.</p>
<p>This method will usually be called by whatever is progressing the game state,
usually a <code>GameStateMachine</code>.</p>
<h2 id="server">Server</h2>
<pre><code class="python">Server(self, game_state_store:pygase.backend.GameStateStore)
</code></pre>

<p>Listen to clients and orchestrate the flow of events and state updates.</p>
<p>The <code>Server</code> instance does not contain game logic or state, it is only responsible for connections
to clients. The state is provided by a <code>GameStateStore</code> and game logic by a <code>GameStateMachine</code>.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>game_state_store (GameStateStore)</strong>: part of the backend that provides an interface to the <code>pygase.GameState</code></li>
</ul>
<p><strong>Attributes</strong></p>
<ul>
<li><code>connections (list)</code>: contains each clients address as a key leading to the
    corresponding <code>pygase.connection.ServerConnection</code> instance</li>
<li><code>host_client (tuple)</code>: address of the host client (who has permission to shutdown the server), if there is any</li>
<li><code>game_state_store (GameStateStore)</code>: game state repository</li>
</ul>
<p><strong>Members</strong></p>
<ul>
<li><code>hostname (str)</code>: read-only access to the servers hostname</li>
<li><code>port (int)</code>: read-only access to the servers port number</li>
</ul>
<h3 id="hostname">hostname</h3>
<p>Get the hostname or IP address on which the server listens.</p>
<p>Returns <code>None</code> when the server is not running.</p>
<h3 id="port">port</h3>
<p>Get the port number on which the server listens.</p>
<p>Returns <code>None</code> when the server is not running.</p>
<h3 id="run">run</h3>
<pre><code class="python">Server.run(self, port:int=0, hostname:str='localhost', event_wire=None) -&gt; None
</code></pre>

<p>Start the server under a specified address.</p>
<p>This is a blocking function but can also be spawned as a coroutine or in a thread
via <code>Server.run_in_thread()</code>.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>port (int)</strong>: port number the server will be bound to, default will be an available
   port chosen by the computers network controller</li>
<li><strong>hostname (str)</strong>: hostname or IP address the server will be bound to.
   Defaults to <code>'localhost'</code>.</li>
<li><strong>event_wire (GameStateMachine)</strong>: object to which events are to be repeated
   (has to implement a <code>_push_event(event)</code> method and is typically a <code>GameStateMachine</code>)</li>
</ul>
<h3 id="run_in_thread">run_in_thread</h3>
<pre><code class="python">Server.run_in_thread(self, port:int=0, hostname:str='localhost', event_wire=None, daemon=True) -&gt; threading.Thread
</code></pre>

<p>Start the server in a seperate thread.</p>
<p>See <code>Server.run()</code>.</p>
<p><strong>Returns</strong></p>
<p><code>threading.Thread</code>: the thread the server loop runs in</p>
<h3 id="shutdown">shutdown</h3>
<pre><code class="python">Server.shutdown(self) -&gt; None
</code></pre>

<p>Shut down the server.</p>
<p>The server can be restarted via <code>Server.run()</code> in which case it will remember previous connections.
This method can also be spawned as a coroutine.</p>
<h3 id="dispatch_event_1">dispatch_event</h3>
<pre><code class="python">Server.dispatch_event(self, event_type:str, *args, target_client='all', retries:int=0, ack_callback=None, **kwargs) -&gt; None
</code></pre>

<p>Send an event to one or all clients.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>event_type (str)</strong>: identifies the event and links it to a handler</li>
<li><strong>target_client (tuple, str)</strong>: either <code>'all'</code> for an event broadcast, or a clients address as a tuple</li>
<li><strong>retries (int)</strong>: number of times the event is to be resent in case it times out</li>
<li><strong>ack_callback (callable, coroutine)</strong>: will be executed after the event was received
    and be passed a reference to the corresponding <code>pygase.connection.ServerConnection</code> instance
Additional positional and keyword arguments will be sent as event data and passed to the clients
handler function.</li>
</ul>
<h3 id="register_event_handler_1">register_event_handler</h3>
<pre><code class="python">Server.register_event_handler(self, event_type:str, event_handler_function) -&gt; None
</code></pre>

<p>Register an event handler for a specific event type.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>event_type (str)</strong>: event type to link the handler function to</li>
<li><strong>handler_func (callable, coroutine)</strong>: will be called for received events of the given type</li>
</ul>
<h2 id="gamestatemachine">GameStateMachine</h2>
<pre><code class="python">GameStateMachine(self, game_state_store:pygase.backend.GameStateStore)
</code></pre>

<p>Run a simulation that propagates the game state.</p>
<p>A <code>GameStateMachine</code> progresses a game state through time, applying all game simulation logic.
This class is meant either as a base class from which you inherit and implement the <code>GameStateMachine.time_step()</code>
method, or you assign an implementation after instantiation.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>game_state_store (GameStateStore)</strong>: part of the PyGaSe backend that provides the state</li>
</ul>
<p><strong>Attributes</strong></p>
<ul>
<li><code>game_time (float)</code>: duration the game has been running in seconds</li>
</ul>
<h3 id="register_event_handler_2">register_event_handler</h3>
<pre><code class="python">GameStateMachine.register_event_handler(self, event_type:str, event_handler_function) -&gt; None
</code></pre>

<p>Register an event handler for a specific event type.</p>
<p>For event handlers to have any effect, the events have to be wired from a <code>Server</code> to
the <code>GameStateMachine</code> via the <code>event_wire</code> argument of the <code>Server.run()</code> method.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>event_type (str)</strong>: which type of event to link the handler function to</li>
<li><strong>handler_func (callable, coroutine)</strong>: function or coroutine to be invoked for events of the given type,
    gets passed the keyword argument <code>game_state</code> (along with those attached to the event)
    and is expected to return an update dict</li>
</ul>
<h3 id="run_game_loop">run_game_loop</h3>
<pre><code class="python">GameStateMachine.run_game_loop(self, interval:float=0.02) -&gt; None
</code></pre>

<p>Simulate the game world.</p>
<p>This function blocks as it continously progresses the game state through time
but it can also be spawned as a coroutine or in a thread via <code>Server.run_game_loop_in_thread()</code>.
As long as the simulation is running, the <code>game_state.status</code> will be <code>GameStatus.get('Active')</code>.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>interval (float)</strong>: (minimum) duration in seconds between consecutive time steps</li>
</ul>
<h3 id="run_game_loop_in_thread">run_game_loop_in_thread</h3>
<pre><code class="python">GameStateMachine.run_game_loop_in_thread(self, interval:float=0.02) -&gt; threading.Thread
</code></pre>

<p>Simulate the game in a seperate thread.</p>
<p>See <code>GameStateMachine.run_game_loop()</code>.</p>
<p><strong>Returns</strong></p>
<p><code>threading.Thread</code>: the thread the game loop runs in</p>
<h3 id="stop">stop</h3>
<pre><code class="python">GameStateMachine.stop(self, timeout:float=1.0) -&gt; bool
</code></pre>

<p>Pause the game simulation.</p>
<p>This sets <code>self.status</code> to <code>Gamestatus.get('Paused')</code>. This method can also be spawned as a coroutine.
A subsequent call of <code>GameStateMachine.run_game_loop()</code> will resume the simulation at the point
where it was stopped.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>timeout (float)</strong>: time in seconds to wait for the simulation to stop</li>
</ul>
<p><strong>Returns</strong></p>
<p><code>bool</code>: wether or not the simulation was successfully stopped</p>
<h3 id="time_step">time_step</h3>
<pre><code class="python">GameStateMachine.time_step(self, game_state:pygase.gamestate.GameState, dt:float) -&gt; dict
</code></pre>

<p>Calculate a game state update.</p>
<p>This method should be implemented to return a dict with all the updated state attributes.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>game_state (GameState)</strong>: the state of the game prior to the time step</li>
<li><strong>dt (float)</strong>: time in seconds since the last time step, use it to simulate at a consistent speed</li>
</ul>
<p><strong>Returns</strong></p>
<p><code>dict</code>: updated game state attributes</p>
<h2 id="backend">Backend</h2>
<pre><code class="python">Backend(self, initial_game_state:pygase.gamestate.GameState, time_step_function, event_handlers:dict=None)
</code></pre>

<p>Easily create a fully integrated PyGaSe backend.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>initial_game_state (GameState)</strong>: state of the game before the simulation begins</li>
<li><strong>time_step_function (callable)</strong>: function that takes a game state and a time difference and returns
    a dict of updated game state attributes (see <code>GameStateMachine.time_step()</code>)</li>
<li><strong>event_handlers (dict)</strong>: a dict with event types as keys and event handler functions as values</li>
</ul>
<p><strong>Attributes</strong></p>
<ul>
<li><code>game_state_store (GameStateStore)</code>: the backends game state repository</li>
<li><code>game_state_machine (GameStateMachine)</code>: logic component that runs the game loop</li>
<li><code>server (Server)</code>: handles connections to PyGaSe clients</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="python"># Run a game loop that continuously increments `foo` with velocity `bar`.
Backend(
    initial_gamestate=GameState(foo=0.0, bar=0.5),
    time_step_function=lambda game_state, dt: {foo: game_state.foo + game_state.bar*dt},
    # Handle client events to reset `foo` and set a new `bar` value.
    event_handlers={
        &quot;RESET_FOO&quot;: lambda game_state, dt: {foo: 0.0},
        &quot;SET_BAR&quot;: lambda new_bar, game_state, dt: {bar: new_bar}
    }
).run(hostname=&quot;localhost&quot;, port=8080)
</code></pre>

<h3 id="run_1">run</h3>
<pre><code class="python">Backend.run(self, hostname:str, port:int)
</code></pre>

<p>Run state machine and server and bind the server to a given address.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>hostname (str)</strong>: hostname or IPv4 address the server will be bound to</li>
<li><strong>port (int)</strong>: port number the server will be bound to</li>
</ul>
<h1 id="pygasegamestate">pygase.gamestate</h1>
<p>Customize a game state model and apply state updates.</p>
<h3 id="contents">Contents</h3>
<ul>
<li><code>TO_DELETE</code>: 4 byte update marker for game state attributes that are to be deleted</li>
<li><code>GameStatus</code>: enum for the status of the game simulation</li>
<li><code>GameState</code>: class for serializable custom state data objects</li>
<li><code>GameStateUpdate</code>: class for serializable objects that express changes to a <em>GameState</em> object</li>
</ul>
<h2 id="gamestatus">GameStatus</h2>
<pre><code class="python">GameStatus(self, /, *args, **kwargs)
</code></pre>

<p>Enum for the game simulation status.</p>
<ul>
<li><code>'Paused'</code></li>
<li><code>'Active'</code></li>
</ul>
<h2 id="gamestate">GameState</h2>
<pre><code class="python">GameState(self, time_order:int=0, game_status:int=0, **kwargs)
</code></pre>

<p>Customize a serializable game state model.</p>
<p>Contains game state information that will be synchronized between the server and the clients.
Via <code>pygase.utils.Sendable</code> its instances will be serialized using the msgpack protocol
and must only contain attributes of type <code>str</code>, <code>bytes</code>, <code>Sqn</code>, <code>int</code>, <code>float</code>, <code>bool</code>
as well as <code>list</code>s or <code>tuple</code>s of such.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>time_order ()</strong>: current time order number of the game state, higher means more recent</li>
<li><strong>game_status ()</strong>: <code>GameStatus</code> enum value that describes whether or not the game loop is running
Provide custom game state attributes via keyword arguments or assign them later.</li>
</ul>
<p><strong>Attributes</strong></p>
<p>game_status ()
 time_order ()
<code>GameState</code> instances mainly consist of custom attributes that make up the game state.</p>
<h3 id="is_paused">is_paused</h3>
<pre><code class="python">GameState.is_paused(self) -&gt; bool
</code></pre>

<p>Return <code>True</code> if game is paused.</p>
<h2 id="gamestateupdate">GameStateUpdate</h2>
<pre><code class="python">GameStateUpdate(self, time_order:int, **kwargs)
</code></pre>

<p>Update a <code>GameState</code> object.</p>
<p>Contains a set of changes to carry out on a <code>GameState</code>.
The server keeps a <code>time_order</code> counter and labels all updates in ascending order.</p>
<p>Attributes of a <code>GameStateUpdate</code> object represent new values of <code>GameState</code> attributes.
To remove game state attributes just assign <code>TO_DELETE</code> to it in the update.</p>
<p>Use the <code>+</code> operator to add updates to one another and combine them or to add them to a
game state in order to update it.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>time_order ()</strong>: the time order up to which the update reaches
game state attributes to be updated</li>
</ul>
<p><strong>Attributes</strong></p>
<p>time_order ()
<code>GameStateUpdate</code> instances mainly consist of custom game state attributes to update.</p>
<h3 id="from_bytes">from_bytes</h3>
<pre><code class="python">GameStateUpdate.from_bytes(bytepack:bytes) -&gt; 'GameStateUpdate'
</code></pre>

<p>Extend <code>Sendable.from_bytes</code> to make sure time_order is of type <code>Sqn</code>.</p>
<h1 id="pygaseconnection">pygase.connection</h1>
<p>Provide low-level networking logic.</p>
<p>This module is not supposed to be required by users of this library.</p>
<p><strong>Contents</strong></p>
<ul>
<li><code>PROTOCOL_ID</code>: 4 byte identifier for the PyGaSe package protocol</li>
<li><code>ProtocolIDMismatchError</code>: exception for receiving non-PyGaSe packages</li>
<li><code>DuplicateSequenceError</code>: exception for duplicate packages</li>
<li><code>Header</code>: class for PyGaSe package headers</li>
<li><code>Package</code>: class for PyGaSe UDP packages</li>
<li><code>ClientPackage</code>: subclass of <code>Package</code> for packages sent by clients</li>
<li><code>ServerPackage</code>: subclass of <code>Package</code> for packages sent by servers</li>
<li><code>ConnectionStatus</code>: enum for the status of a client-server connection</li>
<li><code>Connection</code>: class for the core network logic of client-server connections</li>
<li><code>ClientConnection</code>: subclass of <code>Connection</code> for the client side</li>
<li><code>ServerConnection</code>: subclass of <code>Connectoin</code> for the server side</li>
</ul>
<h2 id="protocolidmismatcherror">ProtocolIDMismatchError</h2>
<pre><code class="python">ProtocolIDMismatchError(self, /, *args, **kwargs)
</code></pre>

<p>Bytestring could not be identified as a valid PyGaSe package.</p>
<h2 id="duplicatesequenceerror">DuplicateSequenceError</h2>
<pre><code class="python">DuplicateSequenceError(self, /, *args, **kwargs)
</code></pre>

<p>Received a package with a sequence number that was already received before.</p>
<h2 id="header">Header</h2>
<pre><code class="python">Header(self, sequence:int, ack:int, ack_bitfield:str)
</code></pre>

<p>Create a PyGaSe package header.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>sequence (int)</strong>: package sequence number</li>
<li><strong>ack (int)</strong>: sequence number of the last received package</li>
<li><strong>ack_bitfield (str)</strong>: A 32 character string representing the 32 sequence numbers prior to the last one received,
    with the first character corresponding the packge directly preceding it and so forth.
    '1' means that package has been received, '0' means it hasn't.</li>
</ul>
<p><strong>Attributes</strong></p>
<ul>
<li><code>sequence (int)</code>: see corresponding constructor argument</li>
<li><code>ack (int)</code>: see corresponding constructor argument</li>
<li><code>ack_bitfield (str)</code>: see corresponding constructor argument</li>
</ul>
<hr />
<ul>
<li><code>Sequence numbers</code>: A sequence of 0 means no packages have been sent or received.
After 65535 sequence numbers wrap around to 1, so they can be stored in 2 bytes.</li>
</ul>
<h3 id="to_bytearray">to_bytearray</h3>
<pre><code class="python">Header.to_bytearray(self) -&gt; bytearray
</code></pre>

<p>Return 12 bytes representing the header.</p>
<h3 id="destructure">destructure</h3>
<pre><code class="python">Header.destructure(self) -&gt; tuple
</code></pre>

<p>Return the tuple <code>(sequence, ack, ack_bitfield)</code>.</p>
<h3 id="deconstruct_datagram">deconstruct_datagram</h3>
<pre><code class="python">Header.deconstruct_datagram(datagram:bytes) -&gt; tuple
</code></pre>

<p>Return a tuple containing the header and the rest of the datagram.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>datagram (bytes)</strong>: serialized PyGaSe package to deconstruct</li>
</ul>
<p><strong>Returns</strong></p>
<p><code>tuple</code>: <code>(header, payload)</code> with <code>payload</code> being a bytestring of the rest of the datagram</p>
<h2 id="package">Package</h2>
<pre><code class="python">Package(self, header:pygase.connection.Header, events:list=None)
</code></pre>

<p>Create a UDP package implementing the PyGaSe protocol.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>header (Header)</strong>: package header</li>
</ul>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>events (pygase.event.Event)</strong>: list events to attach to this package</li>
</ul>
<p><strong>Attributes</strong></p>
<ul>
<li><code>header (Header)</code>:</li>
</ul>
<p><strong>Members</strong></p>
<ul>
<li><code>events (pygase.event.Event)</code>: see corresponding constructor argument</li>
</ul>
<hr />
<p>PyGaSe servers and clients use the subclasses <code>ServerPackage</code> and <code>ClientPackage</code> respectively.
The <code>Package</code> class would also work on its own (it's not an 'abstract' class), in which case you would have
all features of PyGaSe except for a synchronized game state.</p>
<h3 id="events">events</h3>
<p>Get a list of the events in the package.</p>
<h3 id="add_event">add_event</h3>
<pre><code class="python">Package.add_event(self, event:pygase.event.Event) -&gt; None
</code></pre>

<p>Add a PyGaSe event to the package.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>event (pygase.event.Event)</strong>: the event to be attached to this package</li>
</ul>
<p><strong>Raises</strong></p>
<ul>
<li><code>OverflowError</code>: if the package has previously been converted to a datagram and
   and its size with the added event would exceed <code>Package._max_size</code> (2048 bytex)</li>
</ul>
<h3 id="get_bytesize">get_bytesize</h3>
<pre><code class="python">Package.get_bytesize(self) -&gt; int
</code></pre>

<p>Return the size in bytes the package has as a datagram.</p>
<h3 id="to_datagram">to_datagram</h3>
<pre><code class="python">Package.to_datagram(self) -&gt; bytes
</code></pre>

<p>Return package compactly serialized to <code>bytes</code>.</p>
<p><strong>Raises</strong></p>
<ul>
<li><code>OverflowError</code>: if the resulting datagram would exceed <code>Package._max_size</code></li>
</ul>
<h3 id="from_datagram">from_datagram</h3>
<pre><code class="python">Package.from_datagram(datagram:bytes) -&gt; 'Package'
</code></pre>

<p>Deserialize datagram to <code>Package</code>.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>datagram (bytes)</strong>: bytestring to deserialize, typically received via network</li>
</ul>
<p><strong>Returns</strong></p>
<p><code>Package</code>: the deserialized package</p>
<p><strong>Raises</strong></p>
<ul>
<li><code>ProtocolIDMismatchError</code>: if the first four bytes don't match the PyGaSe protocol ID</li>
</ul>
<h2 id="clientpackage">ClientPackage</h2>
<pre><code class="python">ClientPackage(self, header:pygase.connection.Header, time_order:int, events:list=None)
</code></pre>

<p>Subclass of <code>Package</code> for packages sent by PyGaSe clients.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>time_order (int)</strong>: the clients last known time order of the game state</li>
</ul>
<p><strong>Attributes</strong></p>
<ul>
<li><code>time_order (int)</code>: see corresponding constructor argument</li>
</ul>
<h3 id="to_datagram_1">to_datagram</h3>
<pre><code class="python">ClientPackage.to_datagram(self) -&gt; bytes
</code></pre>

<p>Override <code>Package.to_datagram</code> to include <code>time_order</code>.</p>
<h3 id="from_datagram_1">from_datagram</h3>
<pre><code class="python">ClientPackage.from_datagram(datagram:bytes) -&gt; 'ClientPackage'
</code></pre>

<p>Override <code>Package.from_datagram</code> to include <code>time_order</code>.</p>
<h2 id="serverpackage">ServerPackage</h2>
<pre><code class="python">ServerPackage(self, header:pygase.connection.Header, game_state_update:pygase.gamestate.GameStateUpdate, events:list=None)
</code></pre>

<p>Subclass of <code>Package</code> for packages sent by PyGaSe servers.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>game_state_update (pygase.gamestate.GameStateUpdate)</strong>: the servers most recent minimal update for the client</li>
</ul>
<h3 id="to_datagram_2">to_datagram</h3>
<pre><code class="python">ServerPackage.to_datagram(self) -&gt; bytes
</code></pre>

<p>Override <code>Package.to_datagram</code> to include <code>game_state_update</code>.</p>
<h3 id="from_datagram_2">from_datagram</h3>
<pre><code class="python">ServerPackage.from_datagram(datagram:bytes) -&gt; 'ServerPackage'
</code></pre>

<p>Override <code>Package.from_datagram</code> to include <code>game_state_update</code>.</p>
<h2 id="connectionstatus">ConnectionStatus</h2>
<pre><code class="python">ConnectionStatus(self, /, *args, **kwargs)
</code></pre>

<p>Enum for the state of a connection.</p>
<ul>
<li><code>'Disconnected'</code></li>
<li><code>'Connecting'</code></li>
<li><code>'Connected'</code></li>
</ul>
<h2 id="connection">Connection</h2>
<pre><code class="python">Connection(self, remote_address:tuple, event_handler, event_wire=None)
</code></pre>

<p>Exchange packages between PyGaSe clients and servers.</p>
<p>PyGaSe connections exchange events with their other side which are handled using custom handler functions.
They also keep each other informed about which packages have been sent and received and automatically avoid
network congestion.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>remote_address (tuple)</strong>: <code>('hostname', port)</code> for the connection partner's address</li>
<li><strong>event_handler (pygase.event.UniversalEventHandler)</strong>: object that has a callable <code>handle</code> attribute that takes
    a <code>pygase.event.Event</code> as argument</li>
<li><strong>event_wire (pygase.GameStateMachine)</strong>: object to which events are to be repeated
    (has to implement a <code>_push_event</code> method)</li>
</ul>
<p><strong>Attributes</strong></p>
<ul>
<li><code>remote_address (tuple)</code>: see corresponding constructor argument</li>
<li><code>event_handler (pygase.event.UniversalEventHandler)</code>: see corresponding constructor argument</li>
<li><code>event_wire (pygase.GameStateMachine)</code>: see corresponding constructor argument</li>
<li><code>local_sequence (pygase.utils.Sqn)</code>: sequence number of the last sent package</li>
<li><code>remote_sequence (pygase.utils.Sqn)</code>: sequence number of the last received package</li>
<li><code>ack_bitfield (str)</code>: acks for the 32 packages prior to <code>self.remote_sequence</code></li>
<li><code>latency (float)</code>: the last registered RTT (round trip time)</li>
<li><code>status (ConnectionStatus)</code>: an integer value that informs about the state of the connections</li>
<li><code>quality (str)</code>: either <code>'good'</code> or <code>'bad'</code> depending on latency, used internally for
    congestion avoidance</li>
</ul>
<hr />
<p>PyGaSe servers and clients use the subclasses <code>ServerConnection</code> and <code>ClientConnection</code> respectively.
The <code>Connection</code> class would also work on its own (it's not an 'abstract' class), in which case you would have
all features of PyGaSe except for a synchronized game state.</p>
<h3 id="dispatch_event_2">dispatch_event</h3>
<pre><code class="python">Connection.dispatch_event(self, event:pygase.event.Event, ack_callback=None, timeout_callback=None)
</code></pre>

<p>Send an event to the connection partner.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>event (pygase.event.Event)</strong>: the event to dispatch</li>
<li><strong>ack_callback (callable, coroutine)</strong>: will be executed after the event was received</li>
<li><strong>timeout_callback (callable, coroutine)</strong>: will be executed if the event was not received</li>
</ul>
<hr />
<p>Using long-running blocking operations in any of the callback functions can disturb the connection.</p>
<h2 id="clientconnection">ClientConnection</h2>
<pre><code class="python">ClientConnection(self, remote_address:tuple, event_handler)
</code></pre>

<p>Subclass of <code>Connection</code> to describe the client side of a PyGaSe connection.</p>
<p>Client connections hold a copy of the game state which is continously being updated according to
state updates received from the server.</p>
<p><strong>Attributes</strong></p>
<ul>
<li><code>game_state_context (pygase.utils.LockedRessource)</code>: provides thread-safe access to a <code>pygase.GameState</code></li>
</ul>
<h3 id="shutdown_1">shutdown</h3>
<pre><code class="python">ClientConnection.shutdown(self, shutdown_server:bool=False)
</code></pre>

<p>Shut down the client connection.</p>
<p>This method can also be spawned as a coroutine.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>shutdown_server (bool)</strong>: wether or not the server should be shut down too
    (only has an effect if the client has host permissions)</li>
</ul>
<h3 id="loop">loop</h3>
<pre><code class="python">ClientConnection.loop(self)
</code></pre>

<p>Continously operate the connection.</p>
<p>This method will keep sending and receiving packages and handling events until it is cancelled or
the connection receives a shutdown command. It can also be spawned as a coroutine.</p>
<h2 id="serverconnection">ServerConnection</h2>
<pre><code class="python">ServerConnection(self, remote_address:tuple, event_handler, game_state_store, last_client_time_order:pygase.utils.Sqn, event_wire=None)
</code></pre>

<p>Subclass of <code>Connection</code> that describes the server side of a PyGaSe connection.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>game_state_store (pygase.GameStateStore)</strong>: object that serves as an interface to the game state repository
    (has to provide the methods <code>get_gamestate</code>, <code>get_update_cache</code> and <code>push_update</code>)</li>
<li><strong>last_client_time_order (pygase.utils.Sqn)</strong>: the last time order number known to the client</li>
</ul>
<p><strong>Attributes</strong></p>
<ul>
<li><code>game_state_store (pygase.GameStateStore)</code>: see corresponding constructor argument</li>
<li><code>last_client_time_order (pygase.utils.Sqn)</code>: see corresponding constructor argument</li>
</ul>
<h3 id="loop_1">loop</h3>
<pre><code class="python">ServerConnection.loop(hostname:str, port:int, server, event_wire) -&gt; None
</code></pre>

<p>Continously orchestrate and operate connections to clients.</p>
<p>This coroutine will keep listening for client packages, create new <code>ServerConnection</code> objects
when necessary and make sure all packages are handled by and sent via the right connection.</p>
<p>It will return as soon as the server receives a shutdown message.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>hostname (str)</strong>: the hostname or IPv4 address to which to bind the server socket</li>
<li><strong>port (int)</strong>: the port number to which to bind the server socket</li>
<li><strong>server (pygase.Server)</strong>: the server for which this loop is run</li>
<li><strong>event_wire (pygase.GameStateMachine)</strong>: object to which events are to be repeated
   (has to implement a <code>_push_event</code> method)</li>
</ul>
<h1 id="pygaseevent">pygase.event</h1>
<p>Handle events in PyGaSe clients, servers and state machines.</p>
<p>Contains the basic components of the PyGaSe event framework.</p>
<h3 id="contents_1">Contents</h3>
<ul>
<li><code>Event</code>: class for serializable event objects with event type and data</li>
<li><code>UniversalEventHandler</code>: class for components that can handle various event types</li>
</ul>
<h2 id="event">Event</h2>
<pre><code class="python">Event(self, event_type:str, *args, **kwargs)
</code></pre>

<p>Send PyGaSe events and attached data via UDP packages.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>event_type ()</strong>: string that identifies the event and links it to a handler</li>
</ul>
<p><strong>Arguments</strong></p>
<p>Additional positional arguments represent event data and will be passed to the handler function
on the other side of the connection.
keyword arguments to be passed to the handler function on the other side of the connection</p>
<p><strong>Attributes</strong></p>
<ul>
<li><code>type ()</code>:</li>
<li><code>handler_args ()</code>:</li>
<li><code>handler_kwargs ()</code>:</li>
</ul>
<h2 id="universaleventhandler">UniversalEventHandler</h2>
<pre><code class="python">UniversalEventHandler(self)
</code></pre>

<p>Handle PyGaSe events with callback functions.</p>
<h3 id="register_event_handler_3">register_event_handler</h3>
<pre><code class="python">UniversalEventHandler.register_event_handler(self, event_type:str, event_handler_function) -&gt; None
</code></pre>

<p>Register an event handler for a specific event type.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>event_type ()</strong>: string that identifies the events to be handled by this function</li>
<li><strong>event_handler_function ()</strong>: callback function or coroutine that will be invoked with the handler args
   and kwargs with which the incoming event has been dispatched</li>
</ul>
<h3 id="handle">handle</h3>
<pre><code class="python">UniversalEventHandler.handle(self, event:pygase.event.Event, **kwargs)
</code></pre>

<p>Invoke the appropriate handler function.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>event ()</strong>: the event to be handled
keyword arguments to be passed to the handler function (in addition to those already attached to the event)</li>
</ul>
<h3 id="has_event_type">has_event_type</h3>
<pre><code class="python">UniversalEventHandler.has_event_type(self, event_type:str) -&gt; bool
</code></pre>

<p>Check if a handler was registered for <code>event_type</code>.</p>
<h1 id="pygaseutils">pygase.utils</h1>
<p>Use helpful classes and functions.</p>
<p>Provides utilities used in PyGaSe code or helpful to users of this library.</p>
<h3 id="contents_2">Contents</h3>
<ul>
<li><code>Comparable</code>: mixin that makes object compare as equal if their type and attributes match</li>
<li><code>Sendable</code>: mixin that allows to serialize objects to small bytestrings</li>
<li><code>NamedEnum</code>: base class for lists of strings to be mapped to integer values</li>
<li><code>Sqn</code>: subclass of <code>int</code> for sequence numbers that always fit in 2 bytes</li>
<li><code>LockedRessource</code>: class that attaches a <code>threading.Lock</code> to a ressource</li>
<li><code>get_available_ip_addresses</code>: function that returns a list of local network interfaces</li>
</ul>
<h2 id="comparable">Comparable</h2>
<pre><code class="python">Comparable(self, /, *args, **kwargs)
</code></pre>

<p>Compare objects by equality of attributes.</p>
<h2 id="sendable">Sendable</h2>
<pre><code class="python">Sendable(self, /, *args, **kwargs)
</code></pre>

<p>Send objects via UDP packages.</p>
<p>This mixin for classes that are supposed to be sendable as part of a PyGaSe package makes
objects serializable with the msgpack protocol.
Sendables can only have attributes of type <code>str</code>, <code>bytes</code>, <code>Sqn</code>, <code>int</code>, <code>float</code>, <code>bool</code>
as well as <code>list</code>s or <code>tuple</code>s of such.</p>
<h3 id="to_bytes">to_bytes</h3>
<pre><code class="python">Sendable.to_bytes(self) -&gt; bytes
</code></pre>

<p>Serialize the object to a compact bytestring.</p>
<h3 id="from_bytes_1">from_bytes</h3>
<pre><code class="python">Sendable.from_bytes(bytepack:bytes)
</code></pre>

<p>Deserialize a bytestring into an instance of this class.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>bytepack ()</strong>: the bytestring to be parsed to a subclass of <code>Sendable</code></li>
</ul>
<p><strong>Returns</strong></p>
<p>a copy of an object that was serialized via <code>Sendable.to_bytes</code></p>
<h2 id="namedenum">NamedEnum</h2>
<pre><code class="python">NamedEnum(self, /, *args, **kwargs)
</code></pre>

<p>Map string labels to integer values.</p>
<p>This is a base class meant to be subclassed to produce a dynamic enum mapping type.</p>
<p><strong>Example</strong></p>
<pre><code class="python">class MyEnum(NamedEnum):

    '''Encode labels in integers.
     - &quot;foo&quot;
     - &quot;bar&quot;

    '''


    MyEnum.register(&quot;foo&quot;)
    MyEnum.register(&quot;bar&quot;)

    assert MyEnum.get(&quot;foo&quot;) == 1
    assert MyEnum.get(&quot;bar&quot;) == 2
    assert MyEnum.get(1) == &quot;foo&quot;
    assert MyEnum.get(2) == &quot;bar&quot;
</code></pre>

<h3 id="get">get</h3>
<pre><code class="python">NamedEnum.get(name_or_value)
</code></pre>

<p>Get the value for a label or vice versa.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>name_or_value ()</strong>: label or value to de- or encode</li>
</ul>
<p><strong>Returns</strong></p>
<p>int value for given string label or vice versa</p>
<p><strong>Raises</strong></p>
<ul>
<li><code>TypeError</code>: if argument is neither <code>int</code> nor <code>str</code></li>
</ul>
<h3 id="register">register</h3>
<pre><code class="python">NamedEnum.register(name:str) -&gt; None
</code></pre>

<p>Add a new label to the mapping.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>name ()</strong>: string label to register as new enum value</li>
</ul>
<h2 id="sqn">Sqn</h2>
<pre><code class="python">Sqn(self, /, *args, **kwargs)
</code></pre>

<p>Use finite periodic integers that fit in 2 bytes.</p>
<p>Subclass of <code>int</code> that provides a residue-class-like behaviour of wrapping back to 1 after a maximum value.
Use it to represent sequence numbers with a fixed number of bytes when you only need well-defined ordering
within a specific finite scale. 0 represents the state before the sequence has started.</p>
<p>For the default bytesize of 2 the maximum sequence number is 65535.</p>
<h3 id="set_bytesize">set_bytesize</h3>
<pre><code class="python">Sqn.set_bytesize(bytesize:int) -&gt; None
</code></pre>

<p>Redefine the bytesize and wrap-over behaviour for all <code>Sqn</code> instances.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>bytesize ()</strong>: new size for the <code>bytes</code> representation of <code>Sqn</code> instances</li>
</ul>
<h3 id="get_max_sequence">get_max_sequence</h3>
<pre><code class="python">Sqn.get_max_sequence() -&gt; int
</code></pre>

<p>Return the maximum sequence number after which <code>Sqn</code>s wrap back to 1.</p>
<h3 id="to_sqn_bytes">to_sqn_bytes</h3>
<pre><code class="python">Sqn.to_sqn_bytes(self) -&gt; bytes
</code></pre>

<p>Return representation of the number in exactly the currenly set bytesize.</p>
<p>The default bytesize is 2.</p>
<h3 id="from_sqn_bytes">from_sqn_bytes</h3>
<pre><code class="python">Sqn.from_sqn_bytes(bytestring:bytes) -&gt; 'Sqn'
</code></pre>

<p>Return <code>Sqn</code> object that was encoded in given bytestring.</p>
<h2 id="lockedressource">LockedRessource</h2>
<pre><code class="python">LockedRessource(self, ressource)
</code></pre>

<p>Access a ressource thread-safely.</p>
<p>This class makes an object available via a context manager that essentialy attaches a
<code>threading.Lock</code> to it, that threads writing to this object should abide.</p>
<p>Usage example:</p>
<pre><code class="python">myRessource = { 'foo': 'bar' }
myLockedRessource = LockedRessource(myRessource)
with myLockedRessource() as ressource:
    # do stuff without any other threads meddling with the ressource
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><strong>ressource ()</strong>: object to be wrapped</li>
</ul>
<p><strong>Attributes</strong></p>
<ul>
<li><code>lock ()</code>: <code>threading.Lock</code> that threads writing to <code>ressource</code> should abide.
ressource ()</li>
</ul>
<h2 id="get_available_ip_addresses">get_available_ip_addresses</h2>
<pre><code class="python">get_available_ip_addresses() -&gt; list
</code></pre>

<p>Return a list of all locally available IPv4 addresses.</p>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.39abc4af.js"></script>
      
      <script>app.initialize({version:"1.0.4",url:{base:"../.."}})</script>
      
    
  </body>
</html>